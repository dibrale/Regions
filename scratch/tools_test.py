import asyncio
from typing import List, Dict, Any, Callable, Optional
import inspect

# --- Region Registry and Communication ---

# A global registry to hold region instances for inter-region calls
_REGION_REGISTRY: Dict[str, 'NeuralRegion'] = {}


def get_region(region_name: str) -> Optional['NeuralRegion']:
    """Retrieves a NeuralRegion instance by its name."""
    return _REGION_REGISTRY.get(region_name)


# --- Core Neural Region Class ---

class NeuralRegion:
    """
    Represents a simulated brain region within the Default Mode Network.
    It can request information from other regions, summarize it, and respond to requests.
    """

    def __init__(self, name: str, description: str, focus_prompt: str):
        """
        Initializes a NeuralRegion.

        Args:
            name (str): The unique name of the region (e.g., 'HF', 'PHC').
            description (str): A description of the region's primary function.
            focus_prompt (str): A prompt template that defines how this region summarizes
                                information based on its focus.
        """
        self.name = name
        self.description = description
        self.focus_prompt = focus_prompt  # E.g., "Summarize the scene focusing on spatial layout."
        self._api_methods: Dict[str, Callable] = {}
        # Register this instance globally
        _REGION_REGISTRY[self.name] = self

    def register_api_method(self, func: Callable):
        """Registers a method of this class as an API endpoint callable by other regions."""
        sig = inspect.signature(func)
        # Store the function with its name and signature for validation
        self._api_methods[func.__name__] = {
            "function": func,
            "signature": sig,
            "doc": func.__doc__ or f"API method {func.__name__} for {self.name}"
        }

    async def request_information(self, target_region_name: str, method_name: str, **kwargs) -> Any:
        """
        Asynchronously requests information from another region's API method.

        Args:
            target_region_name (str): The name of the region to query.
            method_name (str): The name of the API method to call on the target region.
            **kwargs: Arguments to pass to the target method.

        Returns:
            Any: The result returned by the target region's method.

        Raises:
            ValueError: If the target region or method is not found.
            Exception: If the target method raises an error.
        """
        target_region = get_region(target_region_name)
        if not target_region:
            raise ValueError(f"Region '{target_region_name}' not found.")

        method_info = target_region._api_methods.get(method_name)
        if not method_info:
            raise ValueError(f"Method '{method_name}' not found in region '{target_region_name}'.")

        # In a real API, this would be an HTTP call or similar.
        # Here, we call the method directly on the object.
        try:
            method_func = method_info["function"]
            # Handle both sync and async methods
            if asyncio.iscoroutinefunction(method_func):
                result = await method_func(**kwargs)
            else:
                result = method_func(**kwargs)
            return result
        except Exception as e:
            # Propagate errors from the called method
            raise type(e)(f"Error calling {target_region_name}.{method_name}: {e}") from e

    def summarize_with_focus(self, raw_data: Any, context: Optional[Dict[str, Any]] = None) -> str:
        """
        Summarizes raw data according to this region's specific focus.

        Args:
            raw_data (Any): The data received from other regions.
            context (dict, optional): Additional context for the summary.

        Returns:
            str: A summary tailored to this region's focus.
        """
        # This is a simplified placeholder for the actual LLM-based summarization logic.
        # It would use `self.focus_prompt` and `raw_data` to generate a summary.
        summary = f"[{self.name} Summary] Focus: {self.focus_prompt}\n"
        summary += f"Data: {str(raw_data)[:200]}...\n"
        if context:
            summary += f"Context: {context}\n"
        summary += "[End Summary]"
        return summary

    def respond_to_request(self, summarized_info: str, request_details: Dict[str, Any]) -> str:
        """
        Generates a final response based on the summarized information and the original request.

        Args:
            summarized_info (str): The summary generated by `summarize_with_focus`.
            request_details (dict): Details of the incoming request.

        Returns:
            str: The final response to be sent back to the requesting region.
        """
        # This is a simplified placeholder for the actual LLM-based response generation.
        response = f"[{self.name} Response]\n"
        response += f"Request: {request_details}\n"
        response += f"Summary Used: {summarized_info}\n"
        response += f"[{self.name} Generating detailed response based on its function: {self.description}]"
        return response


# --- Example Region Implementations ---

# 1. Hippocampus (HF) - Episodic Memory
hf_region = NeuralRegion(
    name="HF",
    description="Central to episodic memory. Damage disrupts recall and future imagination.",
    focus_prompt="Extract key events, actors, and temporal sequences from the memory data."
)


@hf_region.register_api_method
async def read_episodic_memory(memory_id: str) -> Dict[str, Any]:
    """Simulates reading an episodic memory."""
    # In a real scenario, this would fetch from a memory store.
    return {
        "id": memory_id,
        "scene": "A sunny park",
        "actors": ["me", "Alice", "Bob"],
        "event": "We had a picnic.",
        "time": "last weekend"
    }


@hf_region.register_api_method
def write_episodic_memory(data: Dict[str, Any]) -> str:
    """Simulates writing an episodic memory."""
    print(f"[HF] Writing memory: {data}")
    return f"Memory '{data.get('id', 'new')}' stored successfully."


# 2. Posterior Hippocampal Cortex (PHC) - Spatial Processing
phc_region = NeuralRegion(
    name="PHC",
    description="Spatial and contextual processing, particularly in scene recognition.",
    focus_prompt="Identify spatial elements, layout, and key landmarks in the scene description."
)


@phc_region.register_api_method
async def get_scene_construction_info(scene: str) -> List[str]:
    """Provides information needed to construct a scene."""
    await asyncio.sleep(0.1)  # Simulate async work
    return [f"Layout for {scene}", f"Objects in {scene}", f"Lighting for {scene}"]


@phc_region.register_api_method
async def get_navigation_path(scene: str, origin: str, destination: str) -> str:
    """Provides a navigation path within a scene."""
    await asyncio.sleep(0.1)
    return f"Path in {scene}: From {origin} to {destination} via the central path."


# 3. Retrosplenial Cortex (RSC) - Spatial Memory & Context
rsc_region = NeuralRegion(
    name="RSC",
    description="Contributes to spatial aspects of memory and navigation.",
    focus_prompt="Highlight the most salient spatial and contextual features of the input."
)


@rsc_region.register_api_method
def describe_scene_elements(scene: str, origin: str, destination: str) -> Dict[str, str]:
    """Describes key elements of a scene."""
    return {
        "scene_overview": f"{scene} is a large, open area.",
        "origin_landmark": f"{origin} is marked by a fountain.",
        "destination_landmark": f"{destination} is near a playground."
    }


# --- Example Usage: Simulating Inter-Region Communication ---

async def simulate_interaction():
    """
    Demonstrates how one region (PHC) can interact with others (HF, RSC).
    """
    print("--- Simulating PHC requesting information and responding ---")

    # 1. PHC receives a request: "What information do I need to construct a park scene?"
    incoming_request = {"scene": "park"}
    print(f"PHC received request: {incoming_request}")

    # 2. PHC identifies it needs more info. It requests from HF.
    print("\n1. PHC requesting detailed scene info from HF...")
    try:
        hf_data = await phc_region.request_information(
            target_region_name="HF",
            method_name="read_episodic_memory",
            memory_id="mem_park_001"
        )
        print(f"   PHC received from HF: {hf_data}")
    except Exception as e:
        print(f"   Error requesting from HF: {e}")
        hf_data = {}

    # 3. PHC also requests specific details from RSC.
    print("\n2. PHC requesting scene description from RSC...")
    try:
        rsc_data = await phc_region.request_information(
            target_region_name="RSC",
            method_name="describe_scene_elements",
            scene=incoming_request["scene"],
            origin="entrance",
            destination="gazebo"
        )
        print(f"   PHC received from RSC: {rsc_data}")
    except Exception as e:
        print(f"   Error requesting from RSC: {e}")
        rsc_data = {}

    # 4. PHC combines the data.
    combined_data = {**hf_data, **rsc_data}
    print(f"\n3. PHC combined data: {combined_data}")

    # 5. PHC summarizes the combined data according to its own focus.
    context_for_summary = {"request_type": "construction_info"}
    summary = phc_region.summarize_with_focus(combined_data, context_for_summary)
    print(f"\n4. PHC summarized data: {summary}")

    # 6. PHC uses the summary to formulate its final response.
    final_response = phc_region.respond_to_request(summary, incoming_request)
    print(f"\n5. PHC final response: {final_response}")


# --- Main Execution ---
if __name__ == "__main__":
    # Run the simulation
    asyncio.run(simulate_interaction())
